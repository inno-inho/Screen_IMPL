<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
    <script>
        // 배열 : 여러가지 자료Type을 저장하기 위한 자료구조
        // 자바와 다르게 한 배열안에 다른 자료형이라도 담을 수 있다
        // let arr = ['str1', "str2", `str3`, null, true, false, undefined, {name: "이인호", age: 15}];
        // console.log(arr);
        // console.log(typeof arr[0]);
        // console.log(typeof arr[1]);
        // console.log(typeof arr[2]);
        // console.log(typeof arr[3]);
        // console.log(typeof arr[4]);
        // console.log(typeof arr[5]);
        // console.log(typeof arr[6]);
        // console.log(typeof arr[7]);
        // //
        // arr[8] = 100;
        // console.log(arr);
        // arr[10] = "Hello world";
        // console.log(arr);
        // console.log(typeof arr[9]);


        // // ---------------------------------------------------------------------------------------------
        // // 배열함수 : push(제일 마지막 위치에 데이터를 쌓는 느낌), pop(제일 마지막 위치의 데이터를 빼는 것)
        // // ---------------------------------------------------------------------------------------------
        // arr.push('aaa');
        // arr.push('bbb');
        // arr.push('ccc');
        // console.log(arr);   // 마지막 index 10번이후의 11번에서 13번까지 데이터가 들어감

        // arr.pop();  // ccc가 사라짐
        // arr.pop();  // bbb가 사라짐
        // console.log(arr);
        
        // // ---------------------------------------------------------------------------------------------
        // // 배열함수 : forEach
        // // ---------------------------------------------------------------------------------------------
        
        // console.log("------------------------------------");
        // arr.forEach((item) => { console.log('item',item);});
        // item str1
        // item str2
        // item str3
        // ......

        // -------------------------------------------------
        // 정렬 : arr.sort((a,b) => {return a-b})
        // -------------------------------------------------

        // let arr2 = [10, 55, 11, 24, 5, 44, 1, 22];
        
        // console.log(arr2);
        // // 오름차순 정렬
        // // arr2.sort();    // 배열은 각 요소의 문자열 반환에 따라 정렬된다. 
        //                 // 그러므로 [1, 10, 11, 22, 24, 44, 5, 55] 제일 앞의 숫자를 기준으로 오름차순 정렬
        // // console.log(arr2);

        // // 진짜 오름차순 정렬
        // // arr2.sort((a, b) => {return a-b;});
        // // console.log(arr2);
        
        // // 내림차순 정렬
        // // arr2.sort((a, b) => {return b-a;});
        // // console.log(arr2);

        // // 약식

        // arr2.sort((a,b) => b-a);
        // console.log(arr2);

        // // -------------------------------------------------
        // // 필터: Array 인스턴스의 filter() 메서드는 주어진 배열의 일부에 대한 얕은 복사본을 생성하고, 주어진 배열에서 제공된 함수에 의해 구현된 테스트를 통과한 요소로만 필터링 합니다.
        // // -------------------------------------------------

        // let arr = ['str1', 22, "str2", 33, `str3`, 10, null, true, false, undefined, 101, {name: "이인호", age: 15}];

        // // 
        // let filtered = arr.filter((item) => {return typeof item == "number";});
        // // 아이템의 타입 중 넘버인거만 반환시켜주세요   
        // // [22, 33, 10, 101]
        // console.log(filtered);
        
        // let result1 = arr.filter((item) => {return typeof item == "string"});
        // console.log(result1);   // ['str1', 'str2', 'str3', 'Hello world']

        // // -------------------------------------------------
        // // 누산: arr.reduce(() => {}, 누산변수 초기값)
        // // -------------------------------------------------

        // const sum = arr.filter((item) => {return typeof item == "number"})               // 숫자값만 필터
        //                         .reduce((sum, item) => {return sum+item}, 0)               // 누적합 구하기

        // console.log(sum);

        //----------------------------------
        // 배열object 처리 [{},{},{},{}...]
        //----------------------------------

        // let arr_5 = [
        //     {pid:"1",pname:"모니터",price:100,amount:50},
        //     {pid:"2",pname:"노트북",price:200,amount:15},
        //     {pid:"3",pname:"냉장고",price:250,amount:30},
        //     {pid:"4",pname:"데스크탑",price:70,amount:19},
        //     {pid:"5",pname:"가습기",price:10,amount:200},
        // ];

        // console.log(arr_5);

        // arr_5.forEach((item) => {console.log(item);})
        // arr_5.forEach((item) => console.log(item))
        // arr_5.forEach((item,index) => {console.log(index, item);}) 
        //  0 {pid: '1', pname: '모니터', price: 100, amount: 50}
        //  1 {pid: '2', pname: '노트북', price: 200, amount: 15}
        //  2 {pid: '3', pname: '냉장고', price: 250, amount: 30}
        //  3 {pid: '4', pname: '데스크탑', price: 70, amount: 19}
        //  4 {pid: '5', pname: '가습기', price: 10, amount: 200}

        // arr_5.forEach((item,index) => {console.log(item["price"]);})    // 가격만 갖고 옴 100 200 250 70 10
        // 각 item의 가격이 100이상인 object만 필터링

        // // const filter_01 = arr_5.filter((item) => {return item["price"] >= 100;})
        // const filter_01 = arr_5.filter(item => item["price"] >= 100)
        // console.log(filter_01);

        // // 각 아이템 수량이 30개 이하인 Object만 필터링
        // // const filter_02 = arr_5.filter((item) => {return item["amount"] <= 30;})
        // const filter_02 = arr_5.filter(item => item.amount <= 30)
        // console.log(filter_02);

        // // 각 아이템 가격이 100만원 이상인 item의 가격 총합을 구하시오

        // // const sum = filter_01.reduce((sum, item) => sum + item.price, 0);
        // // console.log(sum);
        
        // const sum = arr_5.filter((item) => {return item.price >= 100;})
        //                 .reduce((sum,item) => {return sum + (item.amount * item.price);}, 0);
        // console.log('100만원 이상인 item의 누적함', sum)

        // 재구성 배열 .map(() => {})   Array 인스턴스의 map() 메서드는 호출한 배열의 모든 요소에 주어진 함수를 호출한 결과로 채운 새로운 배열을 생성합니다.

        //  let arr_6 = [
        //     {pid:"1",pname:"모니터",price:100,amount:50},
        //     {pid:"2",pname:"노트북",price:200,amount:15},
        //     {pid:"3",pname:"냉장고",price:250,amount:30},
        //     {pid:"4",pname:"데스크탑",price:70,amount:19},
        //     {pid:"5",pname:"가습기",price:10,amount:200},
        // ];

        // let maped_01 = arr_6.map((item) => {
            
        //     // item이라는 배열을 만들어 total_price의 값을 넣는다 total price는 item.price * item.amount
        //     item={...item, "total_price" : item.price * item.amount};
        //     console.log("!", item);
        //     return item; 

        // })

        // 수량이 30이상인 요소만 필터링해서 price가 낮은값 우선 오름차순 / price * amount 항목 추가

        // 내가 한거
        // let filtered = arr_6.filter((item) => {return item.amount >= 30;});
        // let price_filtered = filtered.filter(item => item.price);
        // price_filtered.sort((a,b) => {return a-b;});
        

        // console.log("가격 오름차순", price_filtered);
        // console.log("30이상 필터링", filtered);

        // 선생님이 한거
        // const maped_02 = arr_6.filter((item) => {return item.amount >= 30;})
        //                         .sort((a, b) => {return a.price - b.price;})
        //                         // total_price 요소를 추가한 새로운 배열 생성
        //                         .map((item) => {
        //                             item={...item, "total_price" : item.price * item.amount};
        //                             return item;
        //                         })
        // console.log(maped_02);

         let employees = [
            { id: 1, name: "김철수", age: 35, department: "개발", salary: 6000, years: 10 },
            { id: 2, name: "이영희", age: 28, department: "디자인", salary: 5000, years: 5 },
            { id: 3, name: "박지성", age: 40, department: "마케팅", salary: 7000, years: 15 },
            { id: 4, name: "손흥민", age: 30, department: "개발", salary: 6500, years: 7 },
            { id: 5, name: "정우성", age: 45, department: "경영", salary: 9000, years: 20 },
            { id: 6, name: "한지민", age: 29, department: "디자인", salary: 5200, years: 6 },
            { id: 7, name: "강호동", age: 50, department: "경영", salary: 8500, years: 25 },
            { id: 8, name: "유재석", age: 42, department: "마케팅", salary: 7500, years: 18 },
            { id: 9, name: "송중기", age: 32, department: "개발", salary: 6200, years: 8 },
            { id: 10, name: "수지", age: 26, department: "디자인", salary: 4800, years: 3 }
        ];

        //연봉이(salary) 6000이상이면서 근속연수(years)가 7년이상인(item.salary>=6000 && item.years>=7) 직원만 필터링해서 배열로 저장 확인

        // let filtered_1 = employees.filter((item) => {return item.salary >= 6000 && item.years >= 7;});
        // console.log(filtered_1);

        //모든 직원의 연봉(salary) 기준으로 내림차순 정렬한 배열 새로 만들기

        // employees.sort((a, b) =>{return b.salary - a.salary;}); 
        // console.log(employees);

        //모든 직원의 연봉(salary) 에 근속연수*100 만큼의 보너스를 추가하여 total_salary필드를 추가한 배열을 반환

        // 내가 한거
        // let filter_03 = employees.map((item) => {
        //                                         item = {...item, 
        //                                         "total_salary": item.salary + item.years * 100};
        //                                         return item;
        //                                          })
        // console.log(filter_03);

        // 선생님이 한거

        // const result3 = employees.map((item) => {
        //                         item = {...item, "total_salary": item.salary + (item.years * 100)};
        //                         return item;
        //                     })

        //department(부서) 별로 직원들의 연봉총합을 구하세요
        // console.log(employees);

        // const result4 = employees.reduce((sum,item) => {
        //     // console.log(item);
        //     sum[item.department] = sum[item.department] == undefined?item.salary:sum[item.department] +item.salary;
        //     console.log(sum);
        //     return sum; 
        // }, {});
        // console.log(result4);

        // 연봉(salary)가 가장높은 직원을 찾아 객체하나만 반환(문서에서 find를 찾아보세요 - !)

        const max_item = employees.sort((a,b) => {return b.salary - a.salary;})
        // 연봉을 내림차순으로 정렬한다음 인덱스번호 제일 첫번째거를 선택
        [0];
        console.log(max_item);

        // 최대값 구하기

        // find 쓰기
        // const max_item2 = employees.find((item) => {return item,salary == max_item.salary;});
        // console.log(max_item2);
    </script>


</body>
</html>